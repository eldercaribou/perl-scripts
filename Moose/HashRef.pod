
=pod

=head1 NAME

Moose::Cookbook::Snack::HashRef - (Ab)using the HashRef type constraint
provided by the L<Moose::Util::TypeConstraint> and/or 
L<Moose::Util::TypeConstraints::OptimizedConstraints> classes.

=head1 SYNOPSIS

    package HashDemo;
    use Moose;
    use Moose::Util::TypeConstraints;

    # this attribute is a HashRef
    has 'files' => ( is => 'rw', isa => q(HashRef) );

    sub dump {
        my $self = shift; 
        foreach my $key ( keys(%{$self->files}) ) {
            print qq(this hash key/value pair is $key : )
                . $self->{file}{$key} . qq(\n);
        } # foreach my $key
    } # sub dump_hash
	
    package main;

    my $demo = HashDemo->new( files => { 1 => q(/path/to/some/file) } );
    print qq(First dump:\n);
    $demo->dump;
    # prints "this hash key/value pair is 1 : /path/to/some/file"

    # this replaces the existing HashRef contents
    my %second_hash = ( 2 => q(/path/to/file2), 3 => q(/path/to/file3) );
    $demo->files( \%second_hash );
    print qq(Second dump:\n);
    $demo->dump;
    # prints:
    # "this hash key/value pair is 3 : /path/to/file3"
    # "this hash key/value pair is 2 : /path/to/file2"

    # clear the HashRef; Note, you can't use 'undef' here; see below
    $demo->files( { } );
    print qq(Third dump:\n);
    $demo->dump;
    # prints nothing, the HashRef was cleared

    exit 0;

=head1 DESCRIPTION

The HashRef type constraint is used to store a reference to a hash variable
as an attribute of a Moose object.

=head2 Assigning hashes to a HashRef attribute

Once the object has been created, you can pass a hash (by reference) to that
object's C<HashRef> attribute using that attribute's accessor:

    my %hash = ( 2 => q(/path/to/file2), 3 => q(/path/to/file3) );
    $demo->files( \%hash );

Or you can pass an anonymous hash as well:

    $demo->files( { 2 => q(/path/to/file2), 3 => q(/path/to/file3) } );

You can assign either an anonymous hash or a reference to a hash to a
C<HashRef> object attribute at the time of object creation:

    $demo = HashDemo->new( files => { 1 => q(/path/to/some/file) } );
    # or...
    %hash = ( 1 => q(/path/to/some/file) );
    $demo = HashDemo->new( \%hash );

=head2 Assigning to a HashRef attribute will overwrite

Once you create an object containing a C<HashRef> attribute, if you assign a
new hash reference to that attribute, it will replace any existing hash
reference:

    # this replaces the existing HashRef contents
    $demo->files( { 2 => q(/path/to/file2), 3 => q(/path/to/file3) } );

=head2 Dumping the contents of the HashRef

In order to dump the contents of a C<HashRef> object attribute, you must first
de-reference the C<HashRef>, and then enumerate over it's keys.  

    # the notation '%{$object->hashref_attrib}' allows a 
    # hash reference to be used where a hash is required
    foreach ( keys( %{$object->hashref_attrib} ) ) {
        $scalar = $object->{hashref_attrib}{$_};
        print qq(The value of $_ is $scalar\n);
    }

If that's a little too noisy, you could create a copy of the C<HashRef>, and
then enumerate over that copy:

    my %hash_copy = %{$object->hashref_attrib};
    foreach ( keys(%hash_copy) ) {
       $scalar = $hash_copy{$_};
       print qq(The value of $_ is $scalar\n);
    }

=head2 Appending key/value pairs to a HashRef

In order to append new key/value pairs to the hash referred to by the
C<HashRef>, you will need to make a copy of the hash first, add the new
key/value pairs, then assign the modified copy of the original hash back to
the C<HashRef>:

    my %hash_copy = %{$object->hashref_attrib};
    $hash_copy{$new_key1} = $new_value1;
    $hash_copy{$new_key2} = $new_value2;
    $object->hashref_attrib( \%hash_copy );

Putting the above code into it's own object method would make appending to a
C<HashRef> a trivial operation.

=head2 Clearing the HashRef

Assigning C<undef> to clear a C<HashRef> will not work because the attribute
was defined with a type constraint, meaning that attribute must have 0 or more
of that type of value to be valid.  B<undef> in Perl is not a value, so it
won't work for clearing the C<HashRef>.

If you assign an empty anonymous hash to a C<HashRef> attribute, this will
clear out that attribute yet still satisfy the type constraint.

    # this clears the HashRef
    $demo->files( { } );

=head1 SEE ALSO

=over 4

=item L<Moose::Cookbook::Snack::Types> - Snippets of code for using Types and
Type Constraints

=item L<Moose::Util::TypeConstraints> - Type constraints system for Moose

=back

=head1 AUTHOR

Brian Manning <elspicyjack at gmail dot com>

=head1 COPYRIGHT AND LICENSE

Copyright (c)2008 by Brian Manning

This documentation is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
